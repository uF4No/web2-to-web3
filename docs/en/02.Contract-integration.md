# Integrating the Messages Smart Contract with React

This guide provides step-by-step instructions for integrating the `Messages` smart contract with your React application. It continues from where [01.Smart-contract.md](./01.Smart-contract.md) left off after deploying your contract using Remix IDE, and assumes you've already scaffolded your React project as described in [00.Scaffold-react-project.md](./00.Scaffold-react-project.md).

## Prerequisites

- Smart contract deployed to ZKsync Sepolia Testnet using Remix IDE (as detailed in the [previous guide](./01.Smart-contract.md))
- Contract address and ABI from your Remix deployment
- React application already scaffolded with Wagmi/Viem (as detailed in [00.Scaffold-react-project.md](./00.Scaffold-react-project.md))

## 1. Collect Contract Deployment Information

If you followed [01.Smart-contract.md](./01.Smart-contract.md), you should have:

- Your contract address from the Remix IDE deployment
- The contract ABI from the Remix compiler tab

Keep these handy as we'll need them for the React integration.

If you deployed to ZKsync Sepolia Testnet, you can verify your contract on the [ZKsync Sepolia Explorer](https://sepolia.explorer.zksync.io/) by searching for your contract address.

## 2. Update Network Configuration in wagmi.ts

Since your project was already scaffolded with wagmi, you just need to update the `src/wagmi.ts` file to ensure it includes ZKsync Sepolia Testnet:

```typescript
import { http, createConfig } from 'wagmi'
import { sepolia, zksyncSepoliaTestnet } from 'wagmi/chains'
import { injected } from 'wagmi/connectors'

export const config = createConfig({
  chains: [zksyncSepoliaTestnet, sepolia],
  connectors: [
    injected(),
    // Only using injected connector for simplicity
  ],
  transports: {
    [zksyncSepoliaTestnet.id]: http(),
    [sepolia.id]: http(),
  },
})

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
```

## 3. Add Contract ABI to Your Project

Create a new directory for contract artifacts:

```bash
mkdir -p src/contracts
```

Then create a file `src/contracts/messagesABI.ts` to store your contract ABI:

```typescript
export const messagesABI = [
  // Paste your ABI here from Remix
  // You can find it in the Remix compiler tab under "ABI"
] as const;
```

## 4. Create a Contract Configuration

Create a file to store contract configuration at `src/contracts/messagesContract.ts`:

```typescript
import { messagesABI } from './messagesABI'

// Update with the contract address from your Remix deployment
export const messagesContract = {
  address: '0xYourContractAddressFromRemix' as `0x${string}`, // Replace with your actual contract address from Remix
  abi: messagesABI
}
```

> **Important**: Make sure to replace `0xYourContractAddressFromRemix` with your actual deployed contract address from Remix. This is the address you received after deploying the contract in the previous guide.

## 5. Create React Hooks for Interacting with the Contract

Create a new directory for hooks:

```bash
mkdir -p src/hooks
```

Then create a file `src/hooks/useMessages.ts`:

```typescript
import { useCallback, useState, useEffect } from 'react'
import { 
  useWriteContract, 
  useReadContract, 
  useWatchContractEvent,
  usePublicClient
} from 'wagmi'
import { messagesContract } from '../contracts/messagesContract'

// Define typings for our messages
interface Message {
  sender: `0x${string}`
  message: string
  timestamp: bigint
}

export function useMessages() {
  const [messages, setMessages] = useState<Message[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [offset, setOffset] = useState(0)
  const [hasMore, setHasMore] = useState(true)
  const batchSize = 10n // Number of messages to load per batch as bigint

  // Get the public client for direct contract calls
  const publicClient = usePublicClient()
  
  // Contract write operation
  const { writeContractAsync, isPending: isSending } = useWriteContract()

  // Read latest messages
  const { data: latestMessages, refetch: refetchLatestMessages } = useReadContract({
    address: messagesContract.address,
    abi: messagesContract.abi,
    functionName: 'getLatestMessages',
    args: [batchSize],
  })

  // Get total message count
  const { data: messageCount } = useReadContract({
    address: messagesContract.address,
    abi: messagesContract.abi,
    functionName: 'getMessageCount',
  })

  // Watch for new messages
  useWatchContractEvent({
    address: messagesContract.address,
    abi: messagesContract.abi,
    eventName: 'NewMessage',
    onLogs: () => {
      // When a new message is detected, refetch the latest messages
      refetchLatestMessages()
    },
  })

  // Initialize messages on load - the contract already returns latest messages first
  useEffect(() => {
    if (latestMessages && Array.isArray(latestMessages)) {
      // The latestMessages are already in newest-first order from the contract
      setMessages(latestMessages as unknown as Message[])
      setIsLoading(false)
      setOffset(latestMessages.length)
      setHasMore(messageCount !== undefined && BigInt(latestMessages.length) < messageCount)
    }
  }, [latestMessages, messageCount])

  // Function to load more messages
  const loadMoreMessages = useCallback(async () => {
    if (!hasMore || !publicClient) return
    
    setIsLoading(true)
    try {
      // Read more messages using the public client
      const batchMessages = await publicClient.readContract({
        address: messagesContract.address,
        abi: messagesContract.abi,
        functionName: 'getMessagesBatch',
        args: [BigInt(offset), batchSize],
      })
      
      const result = batchMessages as unknown as Message[]
      
      if (result && result.length > 0) {
        // Append the older messages to the end of the array
        // since we're displaying newest first
        setMessages((prev) => [...prev, ...result])
        setOffset((prev) => prev + result.length)
        setHasMore(
          messageCount !== undefined && 
          BigInt(offset + result.length) < messageCount
        )
      } else {
        setHasMore(false)
      }
    } catch (error) {
      console.error('Error loading more messages:', error)
    } finally {
      setIsLoading(false)
    }
  }, [offset, hasMore, messageCount, publicClient])

  // Function to send a new message
  const sendMessage = useCallback(async (messageText: string) => {
    if (!messageText.trim()) return
    
    try {
      return await writeContractAsync({
        address: messagesContract.address,
        abi: messagesContract.abi,
        functionName: 'sendMessage',
        args: [messageText],
      })
    } catch (error) {
      console.error('Error sending message:', error)
      throw error
    }
  }, [writeContractAsync])

  return {
    messages,
    isLoading,
    hasMore,
    loadMoreMessages,
    sendMessage,
    isSending,
  }
}
```

## 6. Create MessageList Component and Update App Component

Create a new directory for components if it doesn't exist already:

```bash
mkdir -p src/components
```

Then create a component to display the messages in a Twitter-like feed in `src/components/MessageList.tsx`:

```tsx
import React from 'react'
import { useMessages } from '../hooks/useMessages'
import { useAccount } from 'wagmi'

export function MessageList() {
  const { messages, isLoading, hasMore, loadMoreMessages, sendMessage, isSending } = useMessages()
  const { address } = useAccount()
  const [newMessage, setNewMessage] = React.useState('')
  
  // Format address to show only first 6 and last 4 characters
  const formatAddress = (address: string) => {
    return `${address.slice(0, 6)}...${address.slice(-4)}`
  }

  // Handle infinite scroll
  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    const { scrollTop, scrollHeight, clientHeight } = e.currentTarget
    
    // When user reaches bottom, load more messages
    if (scrollHeight - scrollTop - clientHeight < 50 && hasMore && !isLoading) {
      loadMoreMessages()
    }
  }

  const handleSendMessage = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (!newMessage.trim() || !address) return
    
    try {
      await sendMessage(newMessage)
      setNewMessage('')
    } catch (error) {
      console.error('Failed to send message:', error)
    }
  }

  return (
    <div className="twitter-feed-container">
      {/* Compose new message section at the top */}
      <div className="compose-message-section">
        <form onSubmit={handleSendMessage} className="compose-form">
          <input
            type="text"
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="What's happening?"
            disabled={!address || isSending}
            className="compose-input"
          />
          <button 
            type="submit" 
            disabled={!address || isSending || !newMessage.trim()}
            className="compose-button"
          >
            {isSending ? 'Posting...' : 'Post'}
          </button>
        </form>
      </div>
      
      {/* Message feed */}
      <div className="message-feed" onScroll={handleScroll}>
        {/* Messages display newest first - no need for reverse() */}
        {messages.map((msg, index) => (
          <div 
            key={index} 
            className={`message-post ${msg.sender === address ? 'my-post' : ''}`}
          >
            <div className="post-header">
              <span className="post-author">{formatAddress(msg.sender)}</span>
              <span className="post-time">
                {new Date(Number(msg.timestamp) * 1000).toLocaleString()}
              </span>
            </div>
            <div className="post-content">{msg.message}</div>
          </div>
        ))}
        
        {/* Loading indicator */}
        {isLoading && (
          <div className="loading-indicator">
            Loading messages...
          </div>
        )}
        
        {/* Load more button at the bottom */}
        {hasMore && !isLoading && (
          <button 
            onClick={loadMoreMessages} 
            className="load-more-button"
          >
            Show older posts
          </button>
        )}
      </div>
    </div>
  )
}
```

Now update `src/App.tsx` to include the MessageList component:

```tsx
import { useAccount, useConnect, useDisconnect } from 'wagmi'
import { MessageList } from './components/MessageList'

function App() {
  const account = useAccount()
  const { connectors, connect, status, error } = useConnect()
  const { disconnect } = useDisconnect()

  return (
    <div className="app-container">
      <header>
        <h1>Decentralized Messaging</h1>
        <div className="wallet-connection">
          {account.status === 'connected' ? (
            <div className="account-info">
              <span className="wallet-address">
                Connected: {account.addresses?.[0].slice(0, 6)}...{account.addresses?.[0].slice(-4)}
              </span>
              <button type="button" onClick={() => disconnect()} className="disconnect-button">
                Disconnect
              </button>
            </div>
          ) : (
            <div className="connect-buttons">
              {connectors.map((connector) => (
                <button
                  key={connector.uid}
                  onClick={() => connect({ connector })}
                  type="button"
                  className="connect-button"
                >
                  Connect with {connector.name}
                </button>
              ))}
            </div>
          )}
        </div>
      </header>

      <main>
        {account.status === 'connected' ? (
          <MessageList />
        ) : (
          <div className="connect-prompt">
            Please connect your wallet to access the messaging app
          </div>
        )}
      </main>
      
      {error && <div className="error-message">{error.message}</div>}
      {status === 'pending' && <div className="status-message">Connecting...</div>}
    </div>
  )
}

export default App
```

## 7. Add CSS for Styling (Important)

The styling is essential to create a Twitter-like feed. Create or replace the content of `src/index.css` with this CSS:

```css
:root {
  background-color: #f0f2f5;
  color: #333;
  color-scheme: light;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  font-synthesis: none;
  font-weight: 400;
  line-height: 1.5;
  text-rendering: optimizeLegibility;

  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  background-color: #f0f2f5;
  color: #333;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

#root {
  min-height: 100%;
  background-color: #f0f2f5;
  display: flex;
  flex-direction: column;
}

/* App container */
.app-container {
  max-width: 600px;
  width: 100%;
  margin: 0 auto;
  padding: 20px;
  flex-grow: 1;
  background-color: #f0f2f5;
}

/* Header styles */
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid #e1e8ed;
}

header h1 {
  color: #1da1f2;
  margin: 0;
  font-size: 1.5rem;
}

.wallet-connection {
  display: flex;
  align-items: center;
}

.account-info {
  display: flex;
  align-items: center;
  gap: 1rem;
}

.wallet-address {
  font-family: monospace;
  background-color: #f5f8fa;
  padding: 0.5rem 1rem;
  border-radius: 20px;
  border: 1px solid #e1e8ed;
  font-size: 0.9rem;
}

.connect-buttons {
  display: flex;
  gap: 0.5rem;
}

.connect-button, .disconnect-button {
  padding: 0.5rem 1rem;
  border-radius: 20px;
  border: none;
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.2s;
}

.connect-button {
  background-color: #1da1f2;
  color: white;
}

.disconnect-button {
  background-color: #e1e8ed;
  color: #333;
}

.connect-button:hover {
  background-color: #1a91da;
}

.disconnect-button:hover {
  background-color: #d1d8dd;
}

/* Status message */
.status-message {
  text-align: center;
  margin-top: 1rem;
  padding: 0.5rem;
  background-color: #e8f5fe;
  border-radius: 4px;
  color: #1da1f2;
}

/* Twitter-style feed container */
.twitter-feed-container {
  display: flex;
  flex-direction: column;
  height: auto;
  max-width: 600px;
  margin: 0 auto;
  background-color: #ffffff;
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid #e1e8ed;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

/* Compose new message section at the top */
.compose-message-section {
  padding: 15px;
  background-color: #ffffff;
  border-bottom: 1px solid #e1e8ed;
}

.compose-form {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.compose-input {
  width: 100%;
  padding: 15px;
  border: 1px solid #e1e8ed;
  border-radius: 8px;
  font-size: 1rem;
  resize: none;
  box-sizing: border-box;
  outline: none;
  transition: border-color 0.2s;
  background-color: #ffffff;
  color: #333;
}

.compose-input:focus {
  border-color: #1da1f2;
  background-color: #f8fbff;
}

.compose-button {
  align-self: flex-end;
  padding: 8px 16px;
  background-color: #1da1f2;
  color: white;
  border: none;
  border-radius: 20px;
  cursor: pointer;
  font-weight: bold;
  font-size: 0.9rem;
}

.compose-button:disabled {
  background-color: #a5d0f5;
  cursor: not-allowed;
}

/* Message feed */
.message-feed {
  display: flex;
  flex-direction: column;
  max-height: 70vh;
  overflow-y: auto;
  padding: 0;
}

/* Individual post styling */
.message-post {
  padding: 15px;
  border-bottom: 1px solid #e1e8ed;
  transition: background-color 0.2s;
}

.message-post:hover {
  background-color: #f5f8fa;
}

.post-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  font-size: 0.9rem;
}

.post-author {
  font-weight: bold;
  color: #14171a;
}

.post-time {
  color: #657786;
  font-size: 0.8rem;
}

.post-content {
  margin-bottom: 10px;
  line-height: 1.4;
  word-wrap: break-word;
}

/* My posts have a subtle highlight */
.my-post {
  background-color: #f8fafd;
  border-left: 3px solid #1da1f2;
}

/* Loading indicator */
.loading-indicator {
  padding: 20px;
  text-align: center;
  color: #657786;
}

/* Load more button */
.load-more-button {
  margin: 15px auto;
  padding: 8px 16px;
  background-color: #ffffff;
  border: 1px solid #1da1f2;
  color: #1da1f2;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s;
}

.load-more-button:hover {
  background-color: #e8f5fe;
}

/* Connect prompt */
.connect-prompt {
  text-align: center;
  padding: 2rem;
  background-color: #f5f8fa;
  border-radius: 8px;
  border: 1px solid #e1e8ed;
  margin: 2rem auto;
  max-width: 500px;
}

/* Error message */
.error-message {
  color: #e0245e;
  text-align: center;
  margin-top: 1rem;
  padding: 0.5rem;
  background-color: #fde2e7;
  border-radius: 4px;
}
```

This CSS provides styling for:
- Full-page consistent light background
- The app container and header
- Wallet connection buttons and status
- Message list and individual messages
- Input form with a light background and focus state
- Status and error messages

> **Note**: The styling ensures that the background color extends to the full height of the screen and that the input field has a light background for better readability.

## 8. Testing the Integration

1. Make sure your MetaMask wallet is connected to ZKsync Sepolia Testnet
   - Network Name: ZKsync Sepolia Testnet
   - RPC URL: https://sepolia.era.zksync.dev
   - Chain ID: 300
   - Currency Symbol: ETH
   
2. Ensure your contract address is correctly set in `src/contracts/messagesContract.ts`

3. Start your React app:
   ```bash
   npm run dev
   ```

4. Connect your wallet (the same one you used for deploying the contract in Remix)

5. Test sending and receiving messages:
   - Send a new message
   - Verify it appears in the message list
   - Try loading older messages via the "Load More" button or scrolling

## Common Issues and Solutions

- **Gas Estimation Failed**: Make sure your contract is properly deployed to ZKsync Sepolia and the ABI matches exactly
- **Transaction Failed**: Check if you have enough ETH on ZKsync Sepolia to pay for gas
- **Contract Not Found**: Verify that the contract address in your configuration matches the one deployed from Remix
- **MetaMask Network Issues**: Ensure MetaMask is properly configured for ZKsync Sepolia Testnet
- **Pagination Issues**: Double-check the offset calculation in the loadMoreMessages function

## Next Steps

- Add message editing or deletion functionality (requires contract updates)
- Implement user profiles or message reactions
- Add message filtering or search functionality
- Implement end-to-end encryption for private messaging 
- Deploy your contract to ZKsync mainnet for production use 
